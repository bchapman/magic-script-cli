#!/bin/bash -e

###############################################################################
# Documents

# MagicScript - Digest File Format
# https://wiki.magicleap.com/display/SW/MagicScript+-+Digest+File+Format

# MagicScript - Execution Model
# https://wiki.magicleap.com/display/SW/MagicScript+-+Execution+Model

###############################################################################
# Constants

# The program name and directory
PROGRAM_NAME="${0##*/}"
PROGRAM_DIR="${0%/*}"

# The digest file
DIGEST="digest.sha512.signed"

# The digest file header (magic number and command)
DIGEST_MAGIC="\\x23\\xC2\\xA1\\x7F"
DIGEST_COMMAND="sha512sum -c"
DIGEST_HEADER="$(printf "%b%b" "$DIGEST_MAGIC" "$DIGEST_COMMAND")"

###############################################################################
# User options
# See https://git-scm.com/docs/git-rev-parse#_parseopt

OPT_CHECK=
OPT_QUIET=

OPTS_SPEC="$PROGRAM_NAME [<options>] [--] [<modules>]

Sign or check the signature of MagicScript module files.
--
c,check  read the SHA-512 sums from the digest file and check them
q,quiet  run in quiet mode
h,help   show this help
"
eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"

###############################################################################
# Functions

# Usage
usage() {
  exec "$0" -h
}

# Die
die() {
  # Follow the Perl exit code convention.
  printf "%s: error: %s\\n" "$PROGRAM_NAME" "$*" >&2
  exit 255
}

# Head-zero
headz() {
  # Like "head -n1 -z": stop immediately after the first '\0' character.
  # Work around the lack of "head -z" on older systems.
  # Avoid using non-portable and unreliable solutions such as "cut -d '' -f1";
  # an inline Perl script is the best solution. (No, really!)
  local headz_perl_impl='
    binmode STDIN;
    binmode STDOUT;
    while (my $line = <>) {
      if ($line =~ /^([^\0]*\0)/) {
        print $1;
        last;
      } else {
        print $line;
      }
    }
  '
  perl -w -e "$headz_perl_impl" < "$1"
}

# Check and execute command, echoing if not in quiet mode
exec_with_debug() {
  if [[ -z $OPT_QUIET ]]; then
    printf "%s: executing: %s\\n" "$PROGRAM_NAME" "$*" >&2
  fi
  local cmd="$1"
  shift
  if [[ $cmd = "sha512sum" ]]; then
    # macOS portability hack, don't look!
    cmd="shasum -a512"
  elif [[ -z $(command -v "$cmd") ]]; then
    die "program not found: $cmd"
  fi
  $cmd "$@"
}

# Check paths
check_paths() {
  if [[ $# -lt 1 ]]; then
    die "missing module paths"
  fi
  # Perform crude checks against "/file", "./file", "dir/../file", etc.
  for path in "$@"; do
    if (echo "$path" |
        grep -E -e '^[/\\]' -e '^\.\.?[/\\]' -e '[/\\]\.\.?[/\\]' -q); then
      die "module path must be relative and normalized: $path"
    fi
  done
}

# Create unsigned digest, terminated by '\0'
create_unsigned_digest() {
  local path
  local files
  printf "%s\\n" "$DIGEST_HEADER" > "$DIGEST"
  for path in "$@"; do
    # Find "*.js" at $path and (if applicable) in all subdirectories of $path.
    # Remove all redundant directory separator characters that may be
    # produced by the "find" command.
    files="$(find "$path" -name "*.js" | sed 's:[/\\][/\\]*:/:g')"
    if [[ -z $files ]]; then
      die "can't find JavaScript modules at $path"
    fi
    exec_with_debug sha512sum $files >> "$DIGEST"
  done
  printf "#\\0" >> "$DIGEST"
}

# Check unsigned digest, stopping at '\0'
check_unsigned_digest() {
  if ! [[ -f $DIGEST ]]; then
    die "missing digest file: $DIGEST"
  fi
  echo "checking digest header..." >&2
  local header="$(head -n1 "$DIGEST")"
  if [[ $header != $DIGEST_HEADER ]]; then
    die "bad or missing digest header"
  fi
  # TODO: check $DIGEST_HEADER when the platform will be ready to accept it.
  echo "checking digest content..." >&2
  headz "$DIGEST" | exec_with_debug sha512sum -c -
}

# Sign digest
sign_digest() {
  # Find sign-file.
  if [[ -n $SIGN_FILE ]]; then
    # Check the predefined $SIGN_FILE.
    [[ -x $SIGN_FILE ]] || die "can't find \$SIGN_FILE: $SIGN_FILE"
  else
    # Find sign-file in MLSDK.
    MABU="$(command -v mabu)" || die "can't find mabu in MLSDK"
    MLSDK_ROOT="${MABU%/*}"
    [[ -d $MLSDK_ROOT/tools ]] || die "can't find root dir of MLSDK"
    SIGN_FILE="$MLSDK_ROOT/tools/signer/sign-file"
    [[ -x $SIGN_FILE ]] || die "can't find sign-file in MLSDK"
  fi

  # Execute sign-file depending on whether it is in the Nova tree or in MLSDK.
  if [[ -d $ANDROID_BUILD_TOP ]] &&
      [[ $SIGN_FILE -ef $ANDROID_BUILD_TOP/out/host/linux-x86/bin/sign-file ]]; then
    # Use sign-file, privkey and cert from the Nova tree.
    exec_with_debug "$SIGN_FILE" \
        -f sha512 \
        $ANDROID_BUILD_TOP/nova/build/certs/ml_internal.privkey \
        $ANDROID_BUILD_TOP/nova/build/certs/ml_internal.cert \
        "$DIGEST"
  else
    # Use sign-file, privkey and cert from the MLSDK.
    [[ -n $MLCERT ]] || die "missing \$MLCERT"
    [[ -f $MLCERT ]] || die "can't find \$MLCERT: $MLCERT"
    local privkey="${MLCERT%/*}/$(basename "$MLCERT" .cert).privkey"
    [[ -f $privkey ]] || die "can't find privkey file: $privkey"
    exec_with_debug "$SIGN_FILE" \
        -f sha512 \
        "$privkey" \
        "$MLCERT" \
        "$DIGEST"
  fi
}

# Check digest signature
check_signed_digest() {
  echo "TODO: check signature in digest file: $DIGEST"
}

###############################################################################
# Main

main() {
  while [[ $# != 0 ]]; do
    opt="$1"
    shift
    case "$opt" in
    -c | --check )
      OPT_CHECK=1;;
    -q | --quiet )
      OPT_QUIET=1;;
    -- )
      break;;
    -* )
      usage;;
    esac
  done

  if [[ $OPT_CHECK ]]; then
    [[ -z $OPT_QUIET ]] || die "can't check while being quiet"
    check_unsigned_digest && check_signed_digest
  else
    check_paths "$@"
    create_unsigned_digest "$@" && sign_digest
  fi
}

main "$@"
